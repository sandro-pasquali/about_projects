/*
  Andro.js
  by mary rose cook
  http://github.com/maryrosecook/androjs

  Mix behaviour into objects
*/

;(function() {
  function Andro() {};

  Andro.prototype = {
    // Sets up the passed owner object to use behaviours
    setup: function(owner) {
      if(this.isSetup(owner)) {
        throw "Object already set up, or has conflicting property called andro.";
      }
      else {
        owner.andro = {};
        owner.andro.behaviours = [];
        owner.andro.eventer = new Eventer();
      }
    },

    // Shuts down and removes ALL behaviours from passed owner object
    tearDown: function(owner) {
      if(this.checkIsSetup(owner)) {
        this.eventer(owner).unbindAll();
        delete owner.andro; // remove andro from owner object
      }
    },

    // Adds the passed behaviour to the passed owner
    augment: function(owner, behaviourMixin, settings) {
      this.checkIsSetup(owner);
      if(behaviourMixin === undefined) {
        throw "You must pass a behaviour with which to augment the owner.";
      }

      var behaviour = {};
      owner.andro.behaviours.push(behaviour);
      extend(behaviour, behaviourMixin);

      // write exports to owner
      if(behaviour.setup !== undefined) {
        if(settings === undefined) {
          settings = {};
        }

        var exports = behaviour.setup(owner, owner.andro.eventer, settings);
        for(var name in exports) {
          if(owner[name] === undefined) {
            owner[name] = makeFn(exports[name], behaviour);
          }
          else {
            throw "Behaviour export would overwrite existing attribute on owner.";
          }
        }
      }

      return name; // return just in case user wants to do something mental
    },

    // Returns eventer obj for passed owner object
    eventer: function(owner) {
      if(this.checkIsSetup(owner)) {
        return owner.andro.eventer;
      }
    },

    // Returns true if owner has andro obj on it.
    isSetup: function(owner) {
      return owner.andro !== undefined;
    },

    // Returns true if owner has andro obj on it, or throws exception if it doesn't.
    checkIsSetup: function(owner) {
      if(this.isSetup(owner)) {
        return true;
      }

      throw "This object is not set up for Andro.";
    }
  };

  var extend = function(target, extensions) {
    for(var property in extensions) {
      if(extensions[property] && extensions[property].constructor &&
         extensions[property].constructor === Object) {
        target[property] = extend(target[property] || {}, extensions[property]);
      }
      else {
        target[property] = extensions[property];
      }
    }

    return target;
  };

  var makeFn = function(fn, behaviour) {
    return function() {
      return fn.apply(behaviour, arguments);
    };
  };

  function Eventer() {
    this.callbacks = {};
  }

  Eventer.prototype = {
    bind: function(obj, event, callback) {
      this.callbacks[event] = this.callbacks[event] || [];
      this.callbacks[event].push({
        obj: obj,
        callback: callback
      });

      return this;
    },

    unbind: function(obj, event) {
      for(var boundEvent in this.callbacks) {
        for(var i = 0; i < this.callbacks[boundEvent].length; i++) {
          if(this.callbacks[boundEvent][i].obj === obj) {
            this.callbacks[boundEvent].splice(i, 1);
            break;
          }
        }
      }
    },

    unbindAll: function() {
      for(var i in this.callbacks) {
        delete this.callbacks[i];
      }
    },

    emit: function(event, data) {
      this.dispatch(event, data);
      return this;
    },

    dispatch: function(event, data) {
      var callbacks = this.callbacks[event];

      if(callbacks !== undefined) {
        for(var i = 0; i < callbacks.length; i++) {
          var callbackObj = callbacks[i];
          callbackObj.callback.call(callbackObj.obj, data);
        }
      }
    }
  };

  this.Andro = Andro;
}).call(this);
var Base=function(){if(arguments.length)this==window?Base.prototype.extend.call(arguments[0],arguments.callee.prototype):this.extend(arguments[0])};Base.version="1.0.2"; Base.prototype={extend:function(b,d){var g=Base.prototype.extend;if(arguments.length==2){var e=this[b],h=this.constructor?this.constructor.prototype:null;if(e instanceof Function&&d instanceof Function&&e.valueOf()!=d.valueOf()&&/\bbase\b/.test(d)){var a=d;d=function(){var k=this.base,l=this;this.base=e;this.baseClass=h;var m=a.apply(this,arguments);this.base=k;this.baseClass=l;return m};d.valueOf=function(){return a};d.toString=function(){return String(a)}}return this[b]=d}else if(b){var i={toSource:null}, c=["toString","valueOf"];if(Base._prototyping)c[2]="constructor";for(var j=0;f=c[j];j++)b[f]!=i[f]&&g.call(this,f,b[f]);for(var f in b)i[f]||g.call(this,f,b[f])}return this},base:function(){}}; Base.extend=function(b,d){var g=Base.prototype.extend;b||(b={});Base._prototyping=true;var e=new this;g.call(e,b);var h=e.constructor;e.constructor=this;delete Base._prototyping;var a=function(){Base._prototyping||h.apply(this,arguments);this.constructor=a};a.prototype=e;a.extend=this.extend;a.implement=this.implement;a.create=this.create;a.getClassName=this.getClassName;a.toString=function(){return String(h)};a.isInstance=function(c){return typeof c!="undefined"&&c!==null&&c.constructor&&c.constructor.__ancestors&& c.constructor.__ancestors[a.getClassName()]};g.call(a,d);b=h?a:e;b.init instanceof Function&&b.init();if(!a.__ancestors){a.__ancestors={};a.__ancestors[a.getClassName()]=true;var i=function(c){if(c.prototype&&c.prototype.constructor&&c.prototype.constructor.getClassName){a.__ancestors[c.prototype.constructor.getClassName()]=true;i(c.prototype.constructor)}};i(a)}if(a.getClassName)b.className=a.getClassName();return b};Base.implement=function(b){if(b instanceof Function)b=b.prototype;this.prototype.extend(b)}; Base.create=function(){};Base.getClassName=function(){return"Base"};Base.isInstance=function(){};;(function() {
  this.ActivateInstrumentWhileTouching = {
    setup: function(owner, eventer) {
      this.owner = owner;
      eventer.bind(this, "TouchCount:newlyTouching", this.activateInstrument);
      eventer.bind(this, "TouchCount:newlyNotTouching", this.deactivateInstrument);
    },

    activateInstrument: function() {
      this.eachInstrument(function(instrument) {
        instrument.activate();
      });
    },

    deactivateInstrument: function() {
      this.eachInstrument(function(instrument) {
        instrument.deactivate();
      });
    },

    eachInstrument: function(fn) {
      var instruments = ig.game.getEntitiesByType(EntityInstrument);
      for(var i = 0; i < instruments.length; i++) {
        if(instruments[i].name === this.owner.instrument) {
          fn(instruments[i]);
        }
      }
    }
  };
}).call(this);;(function() {
  this.AnimIfTouching = {
    setup: function(owner, eventer, settings) {
      owner.setAnim(owner.color + settings.noTouch);

      eventer.bind(this, "TouchCount:newlyTouching", function() {
        owner.setAnim(owner.color + settings.touch);
      });

      eventer.bind(this, "TouchCount:newlyNotTouching", function() {
        owner.setAnim(owner.color + settings.noTouch);
      });
    }
  };
}).call(this);
;(function() {
  this.AntiGravity = {
    setup: function(owner, eventer, settings) {
      eventer.bind(this, "owner:update", function() {
	      owner.body.ApplyForce(new b2.Vec2(0, settings.y), owner.body.GetPosition());
      });
    }
  };
}).call(this);;(function() {
  this.BenignExploder = {
    setup: function(owner, eventer, settings) {
      eventer.bind(this, "benignExploder:go", function() {
        var absorbedBy = [EntityHuman];

        for(var i = 0; i < settings.count; i++) {
          ig.spawner.add(EntityParticle, owner.pos, {
            width: settings.size, height: settings.size, color: settings.color,
            density:1, collisionStart: 300, maxLife: 4000,
            bullet: false, absorbedBy: absorbedBy
          }, function() {
            this.body.ApplyImpulse(new b2.Vec2((Math.random() - 0.5) * settings.force,
                                               (Math.random() - 0.7) * settings.force),
                                   this.body.GetPosition());
          });
        }
      });
    }
  };
}).call(this);;(function() {
  this.BloodSpurter = {
    setup: function(owner, eventer, settings) {
      eventer.bind(this, "bloodSpurter:go", function(damagerEntity) {
        var mod = 1 / 20;
        for(var i = 0; i < settings.count; i++) {
          ig.spawner.add(EntityParticle, damagerEntity.pos, {
            width: 1, height: 1, color: settings.color,
            density: 0.2, collisionStart:200, maxLife: 1000
          }, function() {
            var x = ig.maths.spread(damagerEntity.body.m_linearVelocity.x * mod);
            var y = ig.maths.spread(damagerEntity.body.m_linearVelocity.y * mod);
            this.body.ApplyImpulse(new b2.Vec2(x, y), this.body.GetPosition());
          });
        }
      });
    }
  }
}).call(this);
;(function() {
  this.ClearByInstrumentOnSolve = {
    setup: function(owner, eventer) {
      eventer.bind(this, "solved", function() {
        var entities = ig.game.getEntitiesByType(EntityDoorActionBlock);
        for(var i = 0; i < entities.length; i++) {
          if(entities[i]["instrument"] === owner.name) {
            entities[i].reapReady();
          }
        }
      });
    }
  };
}).call(this);;(function() {
  this.ClearColorOnTouch = {
    setup: function(owner, eventer) {
      owner.setAnim(owner.color + "throb");

      var self = this;
      eventer.bind(this, "TouchCount:newlyTouching", function(data) {
        ig.leveler.clearBy(EntityDoorActionBlock, function(entity) {
          eventer.unbind(self, "TouchCount:newlyTouching");
          owner.setAnim(owner.color + "on_full");

          return entity["color"] == owner.color && ig.mover.inView(entity);
        });
      });
    }
  };
}).call(this);;(function() {
  this.DamageOnTouch = {
    setup: function(owner, eventer) {
      this.owner = owner;
      eventer.bind(this, "TouchCount:touching", this.touch);
    },

    touch: function(data) {
      if(data.otherEntity instanceof EntityHuman) {
        if(this.movingAtDamageSpeed()) {
          data.otherEntity.receiveDamage(1, data.selfEntity);
        }
      }
    },

    movingAtDamageSpeed: function() {
      return this.owner.body.m_linearVelocity.x > this.DAMAGE_SPEED ||
        this.owner.body.m_linearVelocity.y > this.DAMAGE_SPEED;
    },

    DAMAGE_SPEED: 30
  };
}).call(this);;(function() {
  this.DangerousExploder = {
    setup: function(owner, eventer, settings) {
      eventer.bind(this, "dangerousExploder:go", function() {
        var v = ig.maths.distributedVectors(15);

        for(var i = 0; i < v.length; i++) {
          ig.spawner.add(EntityParticle, {
            x: owner.pos.x + v[i].x * 5, // spawn each particle bit away so they don't bump
            y: owner.pos.y + v[i].y * 5
          }, {
            width: 2, height: 2, color: "white", antiGravity: true, vector: v[i],
            collisionStart: 0, restitution: 1, bullet: false,
            dangerous: true, maxLife: 900, density: 10, absorbedBy: settings.absorbedBy
          }, function() {
            this.body.ApplyImpulse(new b2.Vec2(this.vector.x * settings.force
                                               + (2 * (Math.random() - 0.5)),
                                               this.vector.y * settings.force
                                               + (2 * (Math.random() - 0.5))),
                                   this.body.GetPosition());
          });
        }

        ig.sounder.play("explosionSound");
      });
    }
  }
}).call(this);
;(function() {
  this.ExportIsSolved = {
    touching: null,

    setup: function(owner, eventer) {
      this.owner = owner;
      var self = this;
      eventer.bind(this, "TouchCount:newlyTouching", function(data) {
        this.touching = data.otherEntity;
      });

      eventer.bind(this, "TouchCount:newlyNotTouching", function() {
        this.touching = null;
      });

      return {
        isSolved: function() {
          return owner.solveState === (self.touching !== null).toString()
        }
      };
    }
  };
}).call(this);;(function() {
  this.Ghostable = {
    setup: function(owner, eventer, settings) {
      this.owner = owner;
      this.nervous = new Nervous(this);
      this.nervous.eyes = new Nervous.Eyes(this.nervous, settings.level.solidityMap);
      this.ghost = new Ghost(this.owner, settings.ghostAnim);

      eventer.bind(this, "owner:draw", this.handleGhostDrawing);
      eventer.bind(this, "owner:update", this.handleVisibleDrawing);
    },

    lastSeenTime: 0,
    handleVisibleDrawing: function() {
      if(this.owner.isInView()) {
        if(ig.editor !== undefined
           || ig.game.player.nervous.eyes.lookAt(this.owner).visible()) {
          this.ghost.ownerVisible(this.owner.pos);
          this.owner.currentAnim = this.owner.getCurrentAnim();
          this.lastSeenTime = new Date().getTime();
        }
        else {
          if(ig.maths.timePassed(this.lastSeenTime, 200)) {
            // delayed because sometimes momentarily "lose sight" but actually
            // just cause nervous SM update is late (I think)
            this.owner.currentAnim = null;
            this.ghost.ownerInvisible();
          }
        }
      }
    },

    handleGhostDrawing: function() {
      if(ig.editor === undefined) {
        this.ghost.draw();
      }
    },

    getSize: function() { return this.owner.size; },
    getCenter: function() { return ig.maths.center(this.owner); },
    getPosition: function() { return this.owner.pos; },
  }
}).call(this);
;(function() {
  this.Health = {
    setup: function(owner, eventer, settings) {
      this.health = settings.maxHealth;

      return {
        getHealth: function() {
          return this.health;
        },

        getMaxHealth: function() {
          return settings.maxHealth;
        },

        getDamageLevels: function() {
          return 9;
        },

	      receiveDamage: function(amount, from) {
          if(this.health > 0) { // health gets decremented multiple times for some weird reason
		        this.health -= amount;
            eventer.emit("health:receiveDamage", from);
		        if(this.health <= 0) {
	            owner.reapReady();
		        }
          }
        },

        damageLevel: function() {
          return Math.ceil((owner.getDamageLevels() / owner.getMaxHealth())
                           * owner.getHealth()) - 1;
        }
      }
    }
  }
}).call(this);;(function() {
  this.KillOnDamage = {
    setup: function(owner, eventer, settings) {
      return {
        receiveDamage: function(damage, obj) {
          if(ig.util.inInstances(obj, settings.instances)) {
            owner.reapReady();
          }
        }
      }
    }
  }
}).call(this);;(function() {
  this.KillOnOffscreen = {
    setup: function(owner, eventer) {
      eventer.bind(this, "owner:update", function() {
        if(!owner.isInView()) {
          owner.reapReady();
        }
      });
    }
  };
}).call(this);;(function() {
  this.Loop = {
    loopTimeout: null,

    setup: function(owner, eventer) {
      this.owner = owner;
      this.eventer = eventer;
      eventer.bind(this, "Loop:start", function() {
        this.loop();
      });

      eventer.bind(this, "Loop:stop", function() {
        eventer.emit("stop");
        clearTimeout(this.loopTimeout);
      });
    },

    loop: function() {
      var self = this;
      this.eventer.emit("playing");
      this.loopTimeout = setTimeout(function() {
        self.loop();
      }, this.owner.time * 1000);
    }
  };
}).call(this);;(function() {
  this.OpenSesame = {
    setup: function(owner, eventer, settings) {
      eventer.bind(this, "owner:update", function() {
        if(ig.input.pressed('opendoors')) {
          ig.leveler.clearBy(settings.type, function(entity) {
            return ig.mover.inView(entity);
          });
        }
      });
    }
  };
}).call(this);
;(function() {
  this.Passer = {
    setup: function(owner, eventer, settings) {
      eventer.bind(this, settings.from, function(data) {
        eventer.emit(settings.to, data);
      });
    }
  }
}).call(this);;(function() {
  this.RelaySolveOnTouch = {
    setup: function(owner) {
      return {
        isSolved: function() {
          if(owner.sound === undefined && touching === null) {
            return true;
          }

          if(owner.isBeingTouched()) {
            var touchCount = 0;
            var curToucher = null;
            var touchers = owner.getTouching();
            for(var i in touchers) {
              curToucher = touchers[i];
              touchCount++;
            }

            if(touchCount === 1 &&
               curToucher.sound === owner.sound) {
              return true;
            }
          }

          return false;
        }
      };
    }
  };
}).call(this);;(function() {
  this.SolveAllCorrect = {
    setup: function(owner, eventer) {
      eventer.bind(this, "owner:update", function() {
        for(var i = 0; i < owner.notes.length; i++) {
          if(!owner.notes[i].isSolved()) {
            return;
          }
        }

        eventer.emit("solved");
      });
    }
  };
}).call(this);;(function() {
  this.Targeter = {
    setup: function(owner, eventer) {
      this.owner = owner;
      this.nonPlayerEnemies = ig.game.getEntitiesByType(EntityTurretBlock);

      this.targeting();

      // (use owner nervous below because don't want to have to define getCenter() etc)

      return {
        gotTarget: this.gotTarget
      }
    },

    targeting: function() {
      // lose target if no longer visible
      // might want to keep if acquired but not in field of view (like by hearing shooting)
      if(ig.mover.inView(this.owner)) {
        if(this.gotTarget()
           && (!this.owner.nervous.eyes.lookAt(this.owner.target).visible()
               || !this.owner.target.isAlive())) {
          this.owner.target = undefined;
        }
        // try and get target
        else if(!this.gotTarget()
                || !ig.mover.inView(this.owner.target)
                || !this.owner.nervous.eyes.lookAt(this.owner.target).visible()) {
          this.owner.target = this.getTarget();
        }
      }
      else {
        this.owner.target = undefined;
      }

      var self = this;
      setTimeout(function() {
        self.targeting(self.owner);
      }, 300);
    },

    isValidTarget: function(obj) {
      return ig.mover.inView(obj)
        && obj.isAlive()
        && this.owner.canSee(obj);
    },

    gotTarget: function() {
      return this.owner.target !== undefined;
    },

    getTarget: function() {
      var enemies = this.owner.getEnemies();
      for(var i = 0; i < enemies.length; i++) {
        if(this.isValidTarget(enemies[i])) {
          return enemies[i];
        }
      }
    }
  }
}).call(this);
;(function() {
  this.TearDown = {
    setup: function(owner, eventer, settings) {
      return {
        tearDown: function() {
          ig.andro.tearDown(owner);
        }
      };
    },
  };
}).call(this);;(function() {
  this.Timer = {
    setup: function(owner, eventer, settings) {
      var self = this;
      eventer.bind(this, "timer:start", function() {
        self.createTimeout(eventer, settings);
      });

      eventer.bind(this, "timer:stop", function() {
        clearTimeout(this.timer);
      });
    },

    createTimeout: function(eventer, settings) {
      var self = this;
      this.timer = setTimeout(function() {
        eventer.emit("timer:elapsed");
        if(settings.repeat === true) {
          self.createTimeout(eventer, settings);
        }
      }, settings.time);
    }
  };
}).call(this);
;(function() {
  this.TouchCount = {
    setup: function(owner, eventer, settings) {
      this.owner = owner;
      this.eventer = eventer;
      this.eligibleFn = settings.eligibleFn;
      this.touching = {};

      ig.contactResolver.add(this);

      eventer.bind(this, "owner:collision", this.collision);
      eventer.bind(this, "owner:kill", this.resolveContacts);

      return {
        "isBeingTouched": this.isBeingTouched,
        "getTouching": this.getTouching
      };
    },

    collision: function(data) {
      var self = this;

      // only records as touching if it has an id (has .entity prop)
      if(this.isEligible(data.otherEntity)) {
        if(data.contactType == "add") {
          this.eventer.emit("TouchCount:touch", data);

          this.touchingUpdates(data, function() {
            self.touching[data.otherEntity.id] = data.otherEntity;
          });
        }
        else if(data.contactType == "remove") {
          this.eventer.emit("TouchCount:untouch", data);

          this.touchingUpdates(data, function() {
            delete self.touching[data.otherEntity.id];
          });
        }
      }
    },

    isEligible: function(obj) {
      if(this.isInternalEligible(obj)) {
        if(this.eligibleFn !== undefined) {
          return this.eligibleFn(obj);
        }
        else {
          return true;
        }
      }

      return false;
    },

    isInternalEligible: function(obj) {
      return !ig.util.inInstances(obj, [EntityParticle]) &&
        (obj === undefined || obj.isSensor !== true);
    },

    touchingUpdates: function(data, touchingUpdateFn) {
      var prevBeingTouched = this.isBeingTouched();

      if(data.otherEntity !== undefined) {
        touchingUpdateFn();
        this.handleStateChange(prevBeingTouched, data);
      }
    },

    handleStateChange: function(prevBeingTouched, data) {
      if(!prevBeingTouched && this.isBeingTouched()) {
        this.eventer.emit("TouchCount:newlyTouching", data);
      }
      else if(prevBeingTouched && !this.isBeingTouched()) {
        this.eventer.emit("TouchCount:newlyNotTouching", data);
      }
    },

    isBeingTouched: function() {
      for(var i in this.touching) {
        return true;
      }

      return false;
    },

    getTouching: function() {
      return this.touching;
    },

    resolveContacts: function(obj) {
      var prevBeingTouched = this.isBeingTouched();
      for(var id in this.touching) {
        if(id == obj.id) {
          var toucher = this.touching[id];
          delete this.touching[id];

          this.eventer.emit("TouchCount:untouch", {
            selfEntity: this.owner,
            otherEntity: toucher,
            contactType: "remove"
          });
        }
      }

      this.handleStateChange(prevBeingTouched);
    }
  };
}).call(this);;(function() {
  function CheapRect(obj, x, y, r, b) {
	if(obj !== null)
	{
      var pos = obj.getPosition();
	  this.x = pos.x;
	  this.y = pos.y;
	  this.r = this.x + obj.size.x;
	  this.b = this.y + obj.size.y;
	}
	else
	{
	  this.x = x;
	  this.y = y;
	  this.r = r;
	  this.b = b;
	}
  };

  CheapRect.gen = function(obj) {
    if(obj.staticRect)
      return obj.staticRect;
    else
      return new CheapRect(obj);
  };

  CheapRect.prototype = {
	isIntersecting: function(rect) {
	  return !(this.r < rect.x || this.x > rect.r || this.y > rect.b || this.b < rect.y);
	},

    get: function() { return this; }
  };

  this.CheapRect = CheapRect;


}).call(this);;(function() {
  function Checkpointer(levelName, fromStart) {
    this.levelName = levelName;
    this.clearEvents();

    if(fromStart === false
       && ig.sessioner.get(this.levelCheckpointId()) !== undefined) {
      this.tag(ig.sessioner.get(this.levelCheckpointId()))
    }
  };

  Checkpointer.prototype = {
    tag: function(pos) {
      this.lastPos = pos;
      ig.sessioner.put(this.levelCheckpointId(), pos);
    },

    // not persisted
    event: function(data) {
      this.events.push(data);
    },

    getEvents: function() {
      return this.events;
    },

    clearEvents: function() {
      this.events = [];
    },

    getLastPos: function() {
      return this.lastPos;
    },

    levelCheckpointId: function() {
      return this.levelName + "checkpoint";
    }
  };

  this.Checkpointer = Checkpointer;
}).call(this);function Collider() { };

Collider.prototype = {

  getMoveExtremeties: function(obj) {
    var extremities = {};
    extremities[ig.maths.DIR.LEFT.id] = null;
    extremities[ig.maths.DIR.RIGHT.id] = null;

    var hints = ig.game.getEntitiesByType(EntityEdgeHint);
    for(var i = 0; i < hints.length; i++) {
      var hint = hints[i];
      if(this.lineOfFireDir(obj, hint) !== null) {
        var distance = ig.maths.distance(hint.pos, obj.pos);
        if(distance < 350) {
          var dir = this.directionOf(obj, hint);
          if(extremities[dir] === null
             || distance < ig.maths.distance(extremities[dir].pos, obj.pos)) {
            extremities[dir] = hint;
          }
        }
      }
    }

    return extremities;
  },

  // the spreads are added to either side of the object to generate the danger zone
  lineOfFireDir: function(shooter, target, inXSpread, inYSpread) {
	  var lineOfFireDir = null;
    var shooterCenter = shooter.getCenter();
	  var targetRect = CheapRect.gen(target);

	  var xSpread = ig.system.width; // default to farthest distance within view
	  if(inXSpread !== undefined)
	    xSpread = inXSpread;

	  var ySpread = 0;
	  if(inYSpread !== undefined)
	    ySpread = inYSpread;

	  if(shooterCenter.y <= targetRect.b + ySpread && shooterCenter.y >= targetRect.y - ySpread){
	    if(targetRect.r < shooterCenter.x && targetRect.r > shooterCenter.x - xSpread) {
		    lineOfFireDir = ig.maths.DIR.LEFT.id;
      }
	    else if(targetRect.x > shooterCenter.x && targetRect.r < shooterCenter.x + xSpread) {
		    lineOfFireDir = ig.maths.DIR.RIGHT.id;
      }
	  }

	  return lineOfFireDir;
  },

  directionOf: function(fromObj, toObj) {
	  if(fromObj.getPosition().x < toObj.getPosition().x)
	    return ig.maths.DIR.RIGHT.id;
    else
      return ig.maths.DIR.LEFT.id;
  },

  isOwnedBy: function(shape, potentialOwner) {
    return shape.GetBody().entity !== undefined &&
      shape.GetBody().entity.owner === potentialOwner;
  },

  setupContactListener: function() {
    var contactHandler = function(shape1, shape2, contactType) {
      if(shape1.GetBody().entity !== undefined) {
        if(shape1.GetBody().entity.collision !== undefined) {
          shape1.GetBody().entity.collision(shape1, shape2, contactType);
        }
      }

      if(shape2.GetBody().entity !== undefined) {
        if(shape2.GetBody().entity.collision !== undefined) {
          shape2.GetBody().entity.collision(shape2, shape1, contactType);
        }
      }
    };

    var WorldContactListener = function(){};
    WorldContactListener.prototype = new b2.ContactListener();
    WorldContactListener.prototype.Add = function(point) {
      contactHandler(point.shape1, point.shape2, "add");
    };

    WorldContactListener.prototype.Result = function(point) {
      contactHandler(point.shape1, point.shape2, "result");
    };

    WorldContactListener.prototype.Remove = function(point) {
      contactHandler(point.shape1, point.shape2, "remove");
    };

    WorldContactListener.prototype.Persist = function(point) {
      contactHandler(point.shape1, point.shape2, "persist");
    };

    ig.world.SetContactListener(new WorldContactListener());
  },

  // constants for different solidity map materials
  materials: {
    EMPTY: 0,
    WALL: 1,

    HUMAN: 2,
    MOVEABLE_BLOCK: 3
  },
};
;(function() {
  function ContactResolver() {
    this.toResolve = [];
  };

  ContactResolver.prototype = {
    resolveFor: function(obj) {
      for(var i = 0; i < this.toResolve.length; i++) {
        this.toResolve[i].resolveContacts(obj);
      }
    },

    add: function(toResolve) {
      this.toResolve.push(toResolve);
    }
  };

  this.ContactResolver = ContactResolver;
}).call(this);(function() {
  function Leveler(levelName, fromStart) {
    this.level = eval(levelName);
    this.levelName = levelName;
    ig.sessioner.put("levelName", levelName);

    this.data = this.extractLevelData();
    this.mobileEntities = [EntityHuman,
                           // EntityCrate, EntityBombBlock, EntityDoorActionBlock
                           // removed because do they really affect gameplay?
                          ];

    ig.checkpointer = new Checkpointer(levelName, fromStart);
    this.loadPreLevelModules();
    this.loadLevel();
    this.loadPostLevelModules();
    this.setupContactListener();

    this.solidityMap = this.setupSolidityMap(this.data.collisionLayers["main"]);
    this.setupEntities();
  };

  Leveler.prototype = {
	  loadLevel: function() {
	    ig.game.loadLevel(this.level);
	    for( var i = 0; i < ig.game.backgroundMaps.length; i++ ) {
		    ig.game.backgroundMaps[i].preRender = true;
	    }

	    ig.game.player = ig.game.getEntitiesByType(EntityPlayer)[0];
	  },

    loadCheckpoint: function() {
      var events = ig.checkpointer.getEvents();
      ig.checkpointer.clearEvents();
      for(var i = 0; i < events.length; i++) {
        var event = events[i];
        ig.spawner.add(event.clazz, event.pos, event.settings, event.fn);
      }

      ig.game.player.warpTo(ig.checkpointer.getLastPos());
    },

    tearDown: function() {
      for(var i = 0; i < ig.game.entities.length; i++) {
        if(ig.game.entities[i].tearDown !== undefined) {
          ig.game.entities[i].tearDown(this);
        }
      }
    },

    loadPreLevelModules: function() {
      ig.updater = new Updater();

      ig.updater.add(this);

      ig.reaper = new Reaper();
      ig.updater.add(ig.reaper);

      ig.runner = new Runner();
      ig.updater.add(ig.runner);

      ig.spawner = new Spawner();
      ig.updater.add(ig.spawner);

      ig.mover = new Mover();
      ig.updater.add(ig.mover);

      ig.amp = new Amp();
      ig.machine = new Machine();
      ig.util = new Util();
      ig.contactResolver = new ContactResolver();
    },

    update: function() {
      this.updateSolidityMap();
    },

    loadPostLevelModules: function() {},

    setupContactListener: function() {
      ig.collider.setupContactListener();
    },

    setupEntities: function() {
      for(var i = 0; i < ig.game.entities.length; i++) {
        if(ig.game.entities[i].setup !== undefined) {
          ig.game.entities[i].setup(this);
        }
      }
    },

    getMaxCoordinates: function() { return this.data.maxCoordinates; },
    getTilesize: function() { return this.data.tilesize; },

    inLevel: function(pos) {
      return pos.x >= 0 && pos.x <= this.getMaxCoordinates().x
        && pos.y >= 0 && pos.y <= this.getMaxCoordinates().y;
    },

    clearBy: function(clazz, toBeCleared) {
      var entities = ig.game.getEntitiesByType(clazz);
      for(var i = 0; i < entities.length; i++) {
        if(toBeCleared(entities[i])) {
          entities[i].reapReady();
        }
      }
    },

    extractLevelData: function() {
      var data = {};
      data.level = this.level;

      // setup max coordinates

      var maxWidth = 0;
      var maxHeight = 0;
      var tileSizeOfMax;
      for(var i in this.level.layer) {
        var layer = this.level.layer[i];
        if(layer.width > maxWidth && layer.height > maxHeight) {
          maxWidth = layer.width;
          maxHeight = layer.height;
          tileSizeOfMax = layer.tilesize;
        }
      }

      data.maxCoordinates = {
        x: (tileSizeOfMax * maxWidth) - 1,
        y: (tileSizeOfMax * maxHeight) - 1
      };

      // record tilesize

      for(var i = 0; i < this.level.layer.length; i++)
        if(this.level.layer[i].name === "collision") {
          data.tilesize = this.level.layer[i].tilesize;
          break;
        }

      // store references to collision layers
      data.collisionLayers = [];
      for(var i = 0; i < this.COLLISION_LAYER_NAMES.length; i++)
        for(var j = 0; j < this.level.layer.length; j++)
          if(this.level.layer[j].name === this.COLLISION_LAYER_NAMES[i]) {
            data.collisionLayers[this.level.layer[j].name] = this.level.layer[j];
            break;
          }

      return data;
    },

    getNextLevelName: function() {
      var levels = this.listLevels();
      for(var i = 0; i < levels.length - 1; i++) {
        if(this.levelName === levels[i]
           && window[this.levelName] !== undefined) {
          return levels[i + 1];
        }
      }

      return null;
    },

    setupSolidityMap: function(mainLayer) {
      var tilesize = this.getTilesize();
      var solidityMap = new SolidityMap(mainLayer.data[0].length * tilesize,
                                        mainLayer.data.length * tilesize);

      for(var x = 0; x < mainLayer.data[0].length; x++) {
        for(var y = 0; y < mainLayer.data.length; y++) {
          var tileMaterial = mainLayer.data[y][x];
          var material = tileMaterial < 179 && tileMaterial > 0 ? 1 : 0;
          solidityMap.updateSection({ x: x * tilesize, y: y * tilesize },
                                    tilesize, tilesize,
                                    material,
                                    false);
        }
      }

      return solidityMap;
    },

    updateSolidityMap: function() {
      for(var i = 0; i < this.mobileEntities.length; i++)
      {
        var entities = ig.game.getEntitiesByType(this.mobileEntities[i]);
        if(entities.length > 0) { // if false, probably player respawn - temporary
          this.solidityMap.clear(entities[0].material()); // clear all material for entity type
          for(var j = 0; j < entities.length; j++) {
            this.updateSolidityMapForEntity(entities[j]);
          }
        }
      }
    },

    updateSolidityMapForEntity: function(entity) {
      var entityPos = ig.maths.floor(entity.getPosition());
      if(this.inLevel(entityPos)) {
        this.solidityMap.updateSection(entityPos,
                                       entity.size.x, entity.size.y,
                                       entity.material(),
                                       true);
      }
    },

    listLevels: function() {
      return ["LevelSelect", "LevelA", "LevelB", "LevelC", "LevelD", "LevelE", "LevelF",
              "LevelG", "LevelH", "LevelI", "LevelJ", "LevelK", "LevelL", "LevelM", "LevelN",
              "LevelO", "LevelP", "LevelQ", "LevelR", "LevelS", "LevelT", "LevelU", "LevelV",
              "LevelW", "LevelX", "LevelY", "LevelZ"];
    },

    COLLISION_LAYER_NAMES: ["main", "collision"]
  };

  this.Leveler = Leveler;

  this.Leveler.loadNewLevel = function(levelName, fromStart) {
    if(ig.leveler !== undefined) { // twar down old level
      ig.leveler.tearDown();
    }

    return new Leveler(levelName, fromStart);
  };
}).call(this);
/*
  Machine.js
  by mary rose cook
  http://github.com/maryrosecook/machinejs

  Make behaviour trees in JavaScript.
  See index.html for an example.

  Uses Base.js by Dean Edwards.  Thanks, Dean.
*/

(function() {
  /*
    The tree generator.  Instantiate and then call generateTree(),
    passing the JSON definition of the tree and the object the tree controls.
  */
  var Machine = Base.extend({
    constructor: function() { },

    // makes behaviour tree from passed json and returns the root node
    generateTree: function(treeJson, actor, states) {
      states = states || actor;
      return this.read(treeJson, null, actor, states);
    },

    // reads in all nodes in passed json, constructing a tree of nodes as it goes
    read: function(subTreeJson, parent, actor, states) {
      var node = null;
      if (subTreeJson.pointer == true)
        node = new Pointer(subTreeJson.identifier,
                           subTreeJson.test,
                           subTreeJson.strategy,
                           parent,
                           actor,
                           states);
      else
        node = new State(subTreeJson.identifier,
                         subTreeJson.test,
                         subTreeJson.strategy,
                         parent,
                         actor,
                         states);

      node.report = subTreeJson.report;

      if(subTreeJson.children !== undefined)
        for (var i = 0; i < subTreeJson.children.length; i++)
          node.children[node.children.length] = this.read(subTreeJson.children[i],
                                                          node, actor, states);

      return node;
    }
  }, {
    getClassName: function() {
      return "Machine";
    }
  });

  // EXPORT
  window['Machine'] = Machine;

  /*
    The object for nodes in the tree.
  */
  var Node = Base.extend({
    identifier: null,
    test: null,
    strategy: null,
    parent: null,
    children: null,
    actor: null,
    states: null,
    report: null,

    constructor: function(identifier, test, strategy, parent, actor, states) {
      this.identifier = identifier;
      this.test = test;
      this.strategy = strategy;
      this.parent = parent;
      this.actor = actor;
      this.states = states;
      this.children = [];
    },

    // A tick of the clock.  Returns the next state.
    tick: function() {
      // if(this.actor.team.identifier == "orange")
      //   ig.s.change([this.identifier], function(s) {
      //     console.log(s.identifier)
      //   }, this);

      if (this.isAction()) // run an actual action
        this.run();

      var potentialNextState = this.nextState();
      var actualNextState = null;
      if (potentialNextState !== null)
        actualNextState = potentialNextState.transition();
      else if (this.can()) // no child state, try and stay in this one
        actualNextState = this;
      else // can't stay in this one, so back up the tree
        actualNextState = this.nearestRunnableAncestor().transition();

      return actualNextState;
    },

    // gets next state that would be moved to from current state
    nextState: function() {
      var strategy = this.strategy;
      if (strategy === undefined) {
        var ancestor = this.nearestAncestorWithStrategy();
        if (ancestor !== null)
          strategy = ancestor.strategy;
      }

      if (strategy !== null)
        return this[strategy].call(this);
      else
        return null;
    },

    isTransition: function() {
      return this.children.length > 0 || this instanceof Pointer;
    },

    isAction: function() {
      return !this.isTransition();
    },

    // returns true if actor allowed to enter this state
    can: function() {
      var functionName = this.test; // can specify custom test function name
      if (functionName === undefined) // no override so go with default function name
        functionName = "can" + this.identifier[0].toUpperCase() + this.identifier.substring(1, this.identifier.length);

      if (this.states[functionName] !== undefined)
        return this.states[functionName].call(this.actor);
      else // no canX() function defined - assume can
        return true;
    },

    // switches state to direct child of root state with passed identifier
    // use very sparingly - really only for important events that
    // require machine to temporarily relinquish control over actor
    // e.g. a soldier who is mostly autonomous, but occasionally receives orders
    warp: function(identifier) {
      return this.getRootChild(identifier);
    },

    getRootChild: function(identifier) {
      var rootNodeChildren = this.getRootNode().children;
      for(var i = 0; i < rootNodeChildren.length; i++)
        if(rootNodeChildren[i].identifier == identifier)
          return rootNodeChildren[i];

      return this;
    },

    rootChild: function() {
      return this.getRootChild(this.identifier);
    },

    // returns first child that can run
    prioritised: function() {
      return this.nextRunnable(this.children);
    },

    // gets next runnable node in passed list
    nextRunnable: function(nodes) {
      for (var i = 0; i < nodes.length; i++)
        if (nodes[i].can())
          return nodes[i];

      return null;
    },

    // runs all runnable children in order, then kicks up to children's closest runnable ancestor
    sequential: function() {
      var nextState = null;
      if (this.isAction()) // want to get next runnable child or go back up to grandparent
      {
        var foundThis = false;
        for (var i = 0; i < this.parent.children.length; i++) {
          var sibling = this.parent.children[i];
          if (this.identifier == sibling.identifier)
            foundThis = true;
          else if (foundThis && sibling.can())
            return sibling;
        }
      }
      else // at a sequential parent so try to run first runnable child
      {
        var firstRunnableChild = this.nextRunnable(this.children);
        if (firstRunnableChild !== null)
          return firstRunnableChild;
      }

      return this.nearestRunnableAncestor(); // no more runnable children in the sequence so return first runnable ancestor
    },

    // returns first namesake forebear encountered when going directly up tree
    nearestAncestor: function(test) {
      if (this.parent === null)
        return null;
      else if (test.call(this.parent) === true)
        return this.parent;
      else
        return this.parent.nearestAncestor(test);
    },

    // returns root node of whole tree
    getRootNode: function() {
      if(this.parent === null)
        return this;
      else
        return this.parent.getRootNode();
    },

    nearestAncestorWithStrategy: function() {
      return this.nearestAncestor(function() {
        return this.strategy !== undefined && this.strategy !== null;
      });
    },

    // returns nearest ancestor that can run
    nearestRunnableAncestor: function() {
      return this.nearestAncestor(function() {
        return this.can();
      });
    },

    nearestNamesakeAncestor: function(identifier) {
      return this.nearestAncestor(function() {
        return this.identifier == identifier;
      });
    }
  }, {
    getClassName: function() {
      return "Node";
    }
  });


  /*
    A normal state in the tree.
  */
  var State = Node.extend({
    transition: function() {
      return this;
    },

    // run the behaviour associated with this state
    run: function() {
      this.states[this.identifier].call(this.actor); // run the action
    }
  }, {
    getClassName: function() {
      return "State";
    }
  });

  /*
    A pointer state in the tree.  Directs the actor to a synonymous state
    further up the tree.  Which synonymous state the actor transitions to
    is dependent on the pointer's strategy.
  */
  var Pointer = Node.extend({
    // transition out of this state using the state's strategy
    transition: function() {
      return this[this.strategy].call(this);
    },

    // a strategy that moves to the first synonymous ancestor
    hereditory: function() {
      return this.nearestNamesakeAncestor(this.identifier);
    },


  }, {
    getClassName: function() {
      return "Pointer";
    }
  });
})();function Maths() { };

Maths.prototype = {
  copyPoint: function(point) {
    return { x: point.x, y: point.y };
  },

  opposite: function(dir) {
    return this.dirData(dir).opp;
  },

  // adds change to current.  Resets to zero and continues changing if limit passed.
  // doesn't allow for change that encompasses more than one revolution
  dial: function(current, change, limit) {
    var absolute = current + change;
    if(current === 0 && limit === 0) {
      return 0;
    }
    else if(change < 0 && absolute < 0) {
      return limit + (absolute % limit);
    }
    else if(change > 0 && absolute > limit) {
      // removed (absolute - 1) - can't remember why it was there
      // was stopping change over limit with change of 1
      return absolute % limit;
    }
    else {
      return absolute;
    }
  },

  dirData: function(dir) {
    for(var i in this.DIR) {
      if(this.DIR[i].id === dir) {
        return this.DIR[i];
      }
    }
  },

  distributedVectors: function(num) {
    var v = [];
    var inc = 360 / num;
    for(var i = 0; i < num; i++) {
      v.push(this.angleToVector(i * inc));
    }

    return v;
  },

  vectorTo: function(start, end) {
    return {
      x: end.x - start.x,
      y: end.y - start.y
    };
  },

  spread: function(num) {
    return (num / 2) + num * Math.random();
  },

  jitter: function(value, proportion) {
    var maxAdjust = value * proportion;
    return (value - (maxAdjust / 2)) + (maxAdjust * Math.random());
  },

  distance: function(point1, point2) {
    var x = Math.abs(point1.x - point2.x);
    var y = Math.abs(point1.y - point2.y);
    return Math.sqrt((x * x) + (y * y));
  },

  center: function(obj) {
    if(obj.pos !== null)
      return {
        x: obj.pos.x + (obj.size.x / 2),
        y: obj.pos.y + (obj.size.y / 2),
      };
    else
      return null;
  },

  inside: function(point, obj) {
    objPos = this.floor(obj.pos);
    return point.x >= objPos.x
      && point.y >= objPos.y
      && point.x <= objPos.x + obj.size.x
      && point.y <= objPos.y + obj.size.y;
  },

  angleToVector: function(angle) {
    var r = this.degToRad(angle);

    var x = Math.cos(r) * this.DIR.UP.v.x - Math.sin(r) * this.DIR.UP.v.y;
    var y = Math.sin(r) * this.DIR.UP.v.x + Math.cos(r) * this.DIR.UP.v.y;
    var normalisedVec = this.normalise({ x: x, y: y });
    return normalisedVec;
  },

  vectorToAngle: function(vec) {
    var unitVec = this.normalise(vec);
    var uncorrectedDeg = this.radToDeg(Math.atan2(unitVec.x, -unitVec.y));
    var angle = uncorrectedDeg;
    if(uncorrectedDeg < 0) {
      angle = 360 + uncorrectedDeg;
    }

    return angle;
  },

  normalise: function(vec) {
    var v = this.vToSyl(vec).toUnitVector();
    return this.vFromSyl(v);
  },

  floor: function(pos) {
    return {
      x: Math.floor(pos.x),
      y: Math.floor(pos.y)
    };
  },

  identitySign: function(num) {
    return num < 0 ? -1 : 0;
  },

  withinRange: function(num, comparison, range) {
    return num > comparison - range && num < comparison + range;
  },

  // from: http://www.xarg.org/2010/06/is-an-angle-between-two-other-angles/
  withinSegment: function(n, a, b) {
	  n = (360 + (n % 360)) % 360;
	  a = (3600000 + a) % 360;
	  b = (3600000 + b) % 360;

	  if (a < b) {
		  return a <= n && n <= b;
    }
	  return a <= n || n <= b;
  },

  quickestDirection: function(start, end, limit) {
    var halfLimit = limit / 2;
    if(end > start) {
      return end - start <= halfLimit ? this.DIR.RIGHT.id : this.DIR.LEFT.id;
    }
    else {
      return start - end < halfLimit ? this.DIR.LEFT.id : this.DIR.RIGHT.id;
    }
  },

  timePassed: function(last, interval) { return last + interval < new Date().getTime(); },

  zero: function() { return { x:0, y:0 }; },

  degToRad: function(degrees) { return 0.01745 * degrees; },
  radToDeg: function(rad) { return rad / 0.01745; },

  // from and to Sylvester
  vToSyl: function(vec) { return $V([vec.x, vec.y || 0]); },
  vFromSyl: function(vec) { return { x: vec.e(1), y: vec.e(2) } },

  DIR: {
    LEFT: {
      id: "LEFT", v: { x: -1, y: 0 }, opp: "RIGHT", sign: -1, angle: 270
    },
    RIGHT: {
      id: "RIGHT", v: { x: 1, y: 0 }, opp: "LEFT", sign: 1, angle: 90
    },
    UP: {
      id: "UP", v: { x: 0, y: -1 }, opp: "DOWN", sign: -1, angle: 0
    },
    DOWN: {
      id: "DOWN", v: { x: 0, y: 1 }, opp: "UP", sign: 1, angle: 180
    },
  },

  COLORS: [
    'red',
    'orange',
    'yellow',
    'green',
    'blue',
    'indigo',
    'violet',
    'white'
  ],

  COLOR_TO_SPRITE: {
    'red': 0,
    'orange': 1,
    'yellow': 2,
    'green': 3,
    'blue': 4,
    'indigo': 5,
    'violet': 6,
    'white': 7
  }
};
function Mover() { };

Mover.prototype = {
  hijacked: false,

  update: function() {
    this.screenFollowPlayer();
  },

  screenFollowPlayer: function() {
	  if(ig.game.player && !this.hijacked) {
      this.moveView(ig.game.player.pos);
    }
  },

  moveView: function(pos) {
    var potentialX = pos.x - ig.system.width/2;
    var right = ig.leveler.getMaxCoordinates().x + ig.system.width;
    if(ig.system.width < ig.leveler.getMaxCoordinates().x
       && potentialX > 0
       && potentialX + ig.system.width < right) {
		  ig.game.screen.x = potentialX;
    }

    var potentialY = pos.y - ig.system.height/2;
    var bottom = ig.leveler.getMaxCoordinates().y + ig.system.height;
    if(ig.system.height < ig.leveler.getMaxCoordinates().y
       && potentialY > 0
       && potentialY + ig.system.height < bottom) {
		  ig.game.screen.y = potentialY;
    }
  },

  centreOn: function(pos, time) {
    this.hijacked = true;
    var startPos = { x: ig.game.player.pos.x, y: ig.game.player.pos.y };
    var startTime = new Date().getTime();
    var endTime = startTime + time;

    var self = this;
    (function handleMoveScreenTo() {
      setTimeout(function() {
        var delta = (new Date().getTime() - startTime) / (endTime - startTime);
        var nextPos = {
          x: startPos.x - ((startPos.x - pos.x) * delta),
          y: startPos.y - ((startPos.y - pos.y) * delta)
        };

        self.moveView(nextPos);
        if(delta < 1) {
          handleMoveScreenTo();
        }
        else {
          self.hijacked = false;
        }
      }, 1);
    })();
  },

  dir: function(a, b) {
    return (a - b) / (a - b);
  },

  getEntitiesInView: function(clazz) {
    var entitiesInView = [];
    var entities = ig.game.getEntitiesByType(clazz);
    for(var i = 0; i < entities.length; i++) {
      if(this.inView(entities[i])) {
        entitiesInView.push(entities[i]);
      }
    }

    return entitiesInView;
  },

  inView: function(obj) {
    return obj.getPosition().x >= ig.game.screen.x &&
      obj.getPosition().x <= ig.game.screen.x + ig.system.width &&
      obj.getPosition().y >= ig.game.screen.y &&
      obj.getPosition().y <= ig.game.screen.y + ig.system.height;
  },
};;(function() {
  function Amp() {
    this.listeners = {}; // holds arrays of listeners, keyed on soundType
  };

  Amp.prototype = {
    addListener: function(actor, soundType, response) {
      if(this.listeners[soundType] === undefined)
        this.listeners[soundType] = {};

      this.listeners[soundType][actor.id] = { actor: actor, response: response };
    },

    removeListener: function(actor, soundType) {
      for(var key in this.listeners[soundType])
        if(key == actor.id)
          delete this.listeners[soundType][key];
    },

    // make a sound that will be picked up by listeners
    sound: function(soundType, soundData) {
      if(this.listeners[soundType] !== undefined) {
        for(var key in this.listeners[soundType])
        {
          var actor = this.listeners[soundType][key].actor;
          var response = this.listeners[soundType][key].response;
          response.call(actor, soundData);
        }
      }
    }
  };

  this.Amp = Amp;
}).call(this);/*
  Nervous.js
  by mary rose cook
  http://github.com/maryrosecook/nervousjs

  The eyes and ears of your objects.
*/

;(function() {
  function Nervous(actor) {
    this.actor = actor;
  };

  var inside = function(point, obj) {
    return point.x >= obj.getPosition().x - 1
      && point.y >= obj.getPosition().y - 1
      && point.x <= obj.getPosition().x + obj.getSize().x + 1
      && point.y <= obj.getPosition().y + obj.getSize().y + 1;
  };

  function Eyes(nervous, sm, overlook) {
    this.nervous = nervous;
    this.sm = sm;
    this.overlook = overlook || [];
  };

  Eyes.prototype = {
    lookAt: function(obj, overlook) {
      var self = this;
      if(overlook === undefined) {
        overlook = this.overlook;
      }

      var raycaster = new Raycaster(this.sm);
      var start = ig.maths.floor(this.nervous.actor.getCenter());
      var line = raycaster.bresenhamLinePoints(start, obj.getCenter());
      var observee = raycaster.project(line, start, overlook, function(point, inOverlook) {
        return (raycaster.traversable(point, inOverlook)
                && inside(point, obj) === false)
          || inside(point, self.nervous.actor);
      });

      observee.visible = function() {
        return this.point && inside(this.point, obj);
      };

      return observee;
    },

    // returns the material of obj that can be seen in direction of vector,
    // and pos obj was hit
    lookInDirection: function(vector, overlook) {
      if(overlook === undefined) {
        overlook = this.overlook;
      }

      var raycaster = new Raycaster(this.sm);
      var start = ig.maths.floor(this.nervous.actor.getCenter());
      var end = raycaster.vectorToEndPoint(start, vector);
      var line = raycaster.bresenhamLinePoints(start, end);

      var self = this;
      var observee = raycaster.project(line, start, overlook, function(point, inOverlook) {
        return raycaster.traversable(point, inOverlook)
          || inside(point, self.nervous.actor);
      });

      return observee;
    }
  };


  function Ears(nervous, amp) {
    this.nervous = nervous;
    this.amp = amp;
  };

  Ears.prototype = {
    // Listen out for sounds of type soundType.
    // When they occur, run response, passing soundType and soundMaker.
    listenTo: function(soundType, response) {
      this.amp.addListener(this.nervous.actor, soundType, response);
    },

    // stop listening to everything
    stopListeningTo: function(soundType) {
      this.amp.removeListener(this.nervous.actor, soundType);
    },
  };

  this.Nervous = Nervous;
  this.Nervous.Eyes = Eyes;
  this.Nervous.Ears = Ears;
}).call(this);;(function() {
  function Raycaster(solidityMap) {
    this.solidityMap = solidityMap;
  };

  Raycaster.prototype = {
    project: function(rayLine, start, overlook, altTraversable) {
      var observee = new Observee(rayLine);
      var start = ig.maths.floor(start);
      var runLineBackwards = this.runLineBackwards(rayLine, start);

      var traversable = this.traversable;
      if(altTraversable !== undefined)
        traversable = altTraversable;

      if(rayLine.length > 0)
      {
        var rayPointIndex = 0;
        if(runLineBackwards)
          rayPointIndex = rayLine.length - 1;

        while(true)
        {
          var rayPoint = rayLine[rayPointIndex];
          if(!traversable.call(this, rayPoint, overlook))
          {
            observee.lineOfSight = rayLine.slice(0, rayPointIndex);
            observee.setPoint(rayPoint, this.solidityMap.get(rayPoint));
            break;
          }

          if(runLineBackwards)
          {
            rayPointIndex--;
            if(rayPointIndex < 0) {
              break;
            }
          }
          else
          {
            rayPointIndex++;
            if(rayPointIndex >= rayLine.length) {
              break;
            }
          }
        }
      }

      return observee;
    },

    runLineBackwards: function(rayLine, start) {
      return rayLine[0].x != start.x || rayLine[0].y != start.y;
    },

    // produces end point of a line from start in direction of passed vector
    vectorToEndPoint: function(start, vector) {
      var p = { x: start.x, y: start.y};
      var width = this.solidityMap.width - 1;
      var height = this.solidityMap.height - 1;
      while(true)
      {
        if(p.x < 0 || p.x > width || p.y < 0 || p.y > height)
          break;
        p.x += vector.x;
        p.y += vector.y;
      }

      var x = p.x;
      var y = p.y;
      if(p.x < 0)
        x = 0;
      else if(p.x > width)
        x = width - 1;

      if(p.y < 0)
        y = 0;
      else if(p.y > height)
        y = height - 1;

      return { x:x, y:y };
    },

    bresenhamLinePoints: function(start, end) {
      var start = ig.maths.floor(start);
      var end = ig.maths.floor(end);
      return this.bresenhamLine(start.x, start.y,
                                end.x, end.y);
    },

    bresenhamLine: function(x0, y0, x1, y1) {
      var result = [];

      var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
      var temp = null;
      if(steep === true)
      {
        temp = x0;
        x0 = y0;
        y0 = temp;

        temp = x1;
        x1 = y1;
        y1 = temp;
      }

      if(x0 > x1)
      {
        temp = x0;
        x0 = x1;
        x1 = temp;

        temp = y0;
        y0 = y1;
        y1 = temp;
      }

      var deltaX = x1 - x0;
      var deltaY = Math.abs(y1 - y0);
      var error = 0;
      var yStep;
      var y = y0;
      if(y0 < y1)
        yStep = 1;
      else
        yStep = -1;

      for(var x = x0; x <= x1; x++)
      {
        if(steep === true)
          result.push({ x: y, y: x });
        else
          result.push({ x: x, y: y });

        error += deltaY;
        if(2 * error >= deltaY)
        {
          y += yStep;
          error -= deltaX;
        }
      }

      return result;
    },

    printLine: function(line) {
      var newSm = this.solidityMap.copy();

      var coords = "";
      for(var i = 0; i < line.length; i++)
      {
        coords += line[i].x + "," + line[i].y + " | "
        newSm.sm[line[i].y][line[i].x] = "L";
      }

      console.log(coords);
      newSm.print();
    },

    traversable: function(point, overlook) {
      if(point.x < 0) {
        return true;
      }
      if(point.x >= this.solidityMap.width) {
        return true;
      }
      if(point.y < 0) {
        return true;
      }
      if(point.y >= this.solidityMap.height) {
        return true;
      }

      var material = this.solidityMap.get(point);
      if(SolidityMap.isMaterial(material, 0)) {
        return true;
      }
      else if(overlook !== undefined) {
        for(var i = 0; i < overlook.length; i++) {
          if(SolidityMap.isMaterial(material, overlook[i])) {
            return true;
          }
        }
      }

      return false;
    },
  };


  function Observee(line) {
    this.lineOfSight = line;
    this.point = null;
    this.material = null;
  };

  Observee.prototype = {
    setPoint: function(point, material) {
      this.point = point;
      this.material = material;
    }
  };

  this.Raycaster = Raycaster;
}).call(this);;(function() {
  function SolidityMap(width, height) {
    this.sm = [];
    this.materials = {};

    this.width = width;
    this.height = height;
    for(var x = 0; x < width; x++) {
      for(var y = 0; y < height; y++) {
        if(x === 0)
          this.sm[y] = [];

        this.sm[y][x] = 0;
      }
    }

    SolidityMap.isMaterial = function(material, materials) {
      if(materials instanceof Array) // is a material type
      {
        for(var i = 0; i < materials.length; i++) {
          if(material === materials[i]) {
            return true
          }
        }

        return false;
      }
      else // specific material check
        return material === materials;
    };
  };

  SolidityMap.prototype = {
    // adds a block of filler to the solidityMap
    updateSection: function(p, width, height, filler, clearable) {
      if(this.materials[filler] === undefined) {
        this.materials[filler] = [];
      }

      for(var x = p.x; x < p.x + width; x++) {
        for(var y = p.y; y < p.y + height; y++) {
          this.sm[y][x] = filler;
          if(clearable === true) {
            this.materials[filler].push({ x: x, y: y });
          }
        }
      }
    },

    get: function(p) {
      return this.sm[p.y][p.x];
    },

    isMaterialPos: function(p, materials) {
      return SolidityMap.isMaterial(this.get(p), materials);
    },

    unoccupied: function(p) {
      return this.get(p) === 0;
    },

    occupied: function(p) {
      return this.get(p) !== 0;
    },

    // changes all instances of cells filled with passed material to 0
    clear: function(value) {
      if(this.materials[value] !== undefined) {
        for(var i = 0; i < this.materials[value].length; i++)
        {
          var entry = this.materials[value][i];
          this.sm[entry.y][entry.x] = 0;
        }
      }

      this.materials[value] = [];
    },

    copy: function() {
      var newSm = new SolidityMap(this.width, this.height);

      for(var x = 0; x < this.width; x++)
        for(var y = 0; y < this.height; y++)
      {
        if(x === 0)
          newSm.sm[y] = [];

        newSm.sm[y][x] = this.sm[y][x];
      }

      return newSm;
    },

    print: function(tilesize) {
      var inc = 1;
      if(tilesize !== undefined)
        inc = tilesize;

      for(var y = 0; y < this.height; y += inc)
      {
        var str = "";
        for(var x = 0; x < this.width; x += inc)
          str += this.sm[y][x];

        console.log(str)
      }
    },
  };

  this.SolidityMap = SolidityMap;
}).call(this);;(function() {
  function Reaper() {
    this.reapees = [];
  };

  Reaper.prototype = {
    update: function() {
      this.reap();
    },

    reap: function() {
      while(this.reapees.length > 0) {
        var obj = this.reapees.pop();
        obj.kill();
      }
    },

    add: function(reapee) {
      var added = false;
      if(reapee._reapQueued !== true) {
        this.reapees.push(reapee);
        reapee._reapQueued = true;
        added = true;
      }

      return added;
    }
  };

  this.Reaper = Reaper;
}).call(this);;(function() {
  function Runner() {
    this.runs = [];
  };

  Runner.prototype = {
    update: function() {
      this.run();
    },

    run: function() {
      while(this.runs.length > 0) {
        var run = this.runs.pop();
        run.fn(run.obj);
      }
    },

    add: function(obj, fn) {
      this.runs.push({
        obj: obj,
        fn: fn
      });
    }
  };

  this.Runner = Runner;
}).call(this);(function() {
  function Sessioner() {};

  Sessioner.prototype = {
    put: function(id, value) {
      if(id !== undefined && value !== undefined) {
        localStorage[id] = JSON.stringify(value);
      }
      else {
        throw "Could not store undefined id or value";
      }
    },

    get: function(id) {
      if(localStorage[id] === undefined) {
        return undefined;
      }
      else {
        return JSON.parse(localStorage[id]);
      }
    }
  };

  this.Sessioner = Sessioner;
}).call(this);
/*
  Snowflake.js
  by mary rose cook
  http://github.com/maryrosecook/snowflakejs

  Run code in beautiful and unique situations.
*/

;(function() {
  // Snowflake.js

  function Snowflake() {
    this.actions = {};
  };

  Snowflake.prototype = {
    // runs the passed action once, passing in an optional arg
    once: function(action, arg) {
      var id = this.id(action);
      if(this.actions[id] === undefined)
      {
        this.run(action, arg);
        this.actions[id] = "whatever";
      }
    },

    // runs action every interval seconds, passing optional arg
    every: function(interval, action, arg) {
      var id = this.id(action);
      if(this.actions[id] === undefined)
      {
        this.actions[id] = {
          nextRun: this.calculateNextRun(interval)
        };
      }
      else if(this.actions[id].nextRun < new Date().getTime())
      {
        this.run(action, arg);
        this.actions[id].nextRun = this.calculateNextRun(interval);
      }
    },

    // runs action when watchValues stop changing, passing optional arg
    stuck: function(watchValues, action, arg) {
      this.watchedValueAction(watchValues, function(orig, current) {
        for(var i = 0; i < orig.length; i++)
          if(orig[i] !== current[i])
            return false;

        return true;
      }, action, arg);
    },

    // runs action when watchValues start changing, passing optional arg
    change: function(watchValues, action, arg) {
      this.watchedValueAction(watchValues, function(orig, current) {
        for(var i = 0; i < orig.length; i++)
          if(orig[i] !== current[i])
            return true;

        return false;
      }, action, arg);
    },

    // pretend like this action was never added
    reset: function(action) {
      delete this.actions[this.id(action)];
    },

    // takes function, stringifies it and turns it into a hash to create an identifier
    id: function(action) {
      return this.hashString(action.toString());
    },

    run: function(action, arg) {
      // maybe if action is not function then just console.log
      action(arg);
    },

    calculateNextRun: function(interval) {
      return new Date().getTime() + (interval * 1000);
    },

    watchedValueAction: function(watchValues, watchValueTest, action, arg) {
      var id = this.id(action);
      if(this.actions[id] === undefined)
        this.actions[id] = { watchValues: watchValues };
      else
      {
        if(watchValueTest(this.actions[id].watchValues, watchValues) === true)
          this.run(action, arg);

        // update watchValues
        this.actions[id].watchValues = watchValues;
      }
    },

    // taken from: http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
    hashString: function(str) {
      var hash = 0;
	  if(str.length === 0)
        return hash;

	  for (i = 0; i < str.length; i++)
      {
	    var char = str.charCodeAt(i);
	    var hash = ((hash << 5) -hash ) + char;
	    hash = hash & hash;
	  }

	  return hash;
    },
  };

  this.Snowflake = Snowflake;
}).call(this);;(function() {
  function Sounder() {
    this.lastPlayed = {};
  };

  Sounder.prototype = {
    play: function(soundName) {
      if(this.lastPlayed[soundName] === undefined
         || ig.maths.timePassed(this.lastPlayed[soundName], 130)) {
        ig.game[soundName].play();
        this.lastPlayed[soundName] = new Date().getTime();
      }
    }
  };

  this.Sounder = Sounder;
}).call(this);
;(function() {
  function Spawner() {
    this.spawnees = [];
  };

  Spawner.prototype = {
    update: function() {
      this.spawn();
    },

    spawn: function() {
      while(this.spawnees.length > 0) {
        var obj = this.spawnees.pop();
	      var entity = ig.game.spawnEntity(obj.clazz, obj.pos.x, obj.pos.y, obj.settings);
        if(obj.fn !== undefined) {
          obj.fn.call(entity);
        }
      }
    },

    add: function(clazz, pos, settings, fn) {
      this.spawnees.push({
        clazz: clazz,
        pos: { x: pos.x, y: pos.y },
        settings: settings || {},
        fn: fn
      });
    }
  };

  this.Spawner = Spawner;
}).call(this);
eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('9 17={3i:\'0.1.3\',16:1e-6};l v(){}v.23={e:l(i){8(i<1||i>7.4.q)?w:7.4[i-1]},2R:l(){8 7.4.q},1u:l(){8 F.1x(7.2u(7))},24:l(a){9 n=7.4.q;9 V=a.4||a;o(n!=V.q){8 1L}J{o(F.13(7.4[n-1]-V[n-1])>17.16){8 1L}}H(--n);8 2x},1q:l(){8 v.u(7.4)},1b:l(a){9 b=[];7.28(l(x,i){b.19(a(x,i))});8 v.u(b)},28:l(a){9 n=7.4.q,k=n,i;J{i=k-n;a(7.4[i],i+1)}H(--n)},2q:l(){9 r=7.1u();o(r===0){8 7.1q()}8 7.1b(l(x){8 x/r})},1C:l(a){9 V=a.4||a;9 n=7.4.q,k=n,i;o(n!=V.q){8 w}9 b=0,1D=0,1F=0;7.28(l(x,i){b+=x*V[i-1];1D+=x*x;1F+=V[i-1]*V[i-1]});1D=F.1x(1D);1F=F.1x(1F);o(1D*1F===0){8 w}9 c=b/(1D*1F);o(c<-1){c=-1}o(c>1){c=1}8 F.37(c)},1m:l(a){9 b=7.1C(a);8(b===w)?w:(b<=17.16)},34:l(a){9 b=7.1C(a);8(b===w)?w:(F.13(b-F.1A)<=17.16)},2k:l(a){9 b=7.2u(a);8(b===w)?w:(F.13(b)<=17.16)},2j:l(a){9 V=a.4||a;o(7.4.q!=V.q){8 w}8 7.1b(l(x,i){8 x+V[i-1]})},2C:l(a){9 V=a.4||a;o(7.4.q!=V.q){8 w}8 7.1b(l(x,i){8 x-V[i-1]})},22:l(k){8 7.1b(l(x){8 x*k})},x:l(k){8 7.22(k)},2u:l(a){9 V=a.4||a;9 i,2g=0,n=7.4.q;o(n!=V.q){8 w}J{2g+=7.4[n-1]*V[n-1]}H(--n);8 2g},2f:l(a){9 B=a.4||a;o(7.4.q!=3||B.q!=3){8 w}9 A=7.4;8 v.u([(A[1]*B[2])-(A[2]*B[1]),(A[2]*B[0])-(A[0]*B[2]),(A[0]*B[1])-(A[1]*B[0])])},2A:l(){9 m=0,n=7.4.q,k=n,i;J{i=k-n;o(F.13(7.4[i])>F.13(m)){m=7.4[i]}}H(--n);8 m},2Z:l(x){9 a=w,n=7.4.q,k=n,i;J{i=k-n;o(a===w&&7.4[i]==x){a=i+1}}H(--n);8 a},3g:l(){8 S.2X(7.4)},2d:l(){8 7.1b(l(x){8 F.2d(x)})},2V:l(x){8 7.1b(l(y){8(F.13(y-x)<=17.16)?x:y})},1o:l(a){o(a.K){8 a.1o(7)}9 V=a.4||a;o(V.q!=7.4.q){8 w}9 b=0,2b;7.28(l(x,i){2b=x-V[i-1];b+=2b*2b});8 F.1x(b)},3a:l(a){8 a.1h(7)},2T:l(a){8 a.1h(7)},1V:l(t,a){9 V,R,x,y,z;2S(7.4.q){27 2:V=a.4||a;o(V.q!=2){8 w}R=S.1R(t).4;x=7.4[0]-V[0];y=7.4[1]-V[1];8 v.u([V[0]+R[0][0]*x+R[0][1]*y,V[1]+R[1][0]*x+R[1][1]*y]);1I;27 3:o(!a.U){8 w}9 C=a.1r(7).4;R=S.1R(t,a.U).4;x=7.4[0]-C[0];y=7.4[1]-C[1];z=7.4[2]-C[2];8 v.u([C[0]+R[0][0]*x+R[0][1]*y+R[0][2]*z,C[1]+R[1][0]*x+R[1][1]*y+R[1][2]*z,C[2]+R[2][0]*x+R[2][1]*y+R[2][2]*z]);1I;2P:8 w}},1t:l(a){o(a.K){9 P=7.4.2O();9 C=a.1r(P).4;8 v.u([C[0]+(C[0]-P[0]),C[1]+(C[1]-P[1]),C[2]+(C[2]-(P[2]||0))])}1d{9 Q=a.4||a;o(7.4.q!=Q.q){8 w}8 7.1b(l(x,i){8 Q[i-1]+(Q[i-1]-x)})}},1N:l(){9 V=7.1q();2S(V.4.q){27 3:1I;27 2:V.4.19(0);1I;2P:8 w}8 V},2n:l(){8\'[\'+7.4.2K(\', \')+\']\'},26:l(a){7.4=(a.4||a).2O();8 7}};v.u=l(a){9 V=25 v();8 V.26(a)};v.i=v.u([1,0,0]);v.j=v.u([0,1,0]);v.k=v.u([0,0,1]);v.2J=l(n){9 a=[];J{a.19(F.2F())}H(--n);8 v.u(a)};v.1j=l(n){9 a=[];J{a.19(0)}H(--n);8 v.u(a)};l S(){}S.23={e:l(i,j){o(i<1||i>7.4.q||j<1||j>7.4[0].q){8 w}8 7.4[i-1][j-1]},33:l(i){o(i>7.4.q){8 w}8 v.u(7.4[i-1])},2E:l(j){o(j>7.4[0].q){8 w}9 a=[],n=7.4.q,k=n,i;J{i=k-n;a.19(7.4[i][j-1])}H(--n);8 v.u(a)},2R:l(){8{2D:7.4.q,1p:7.4[0].q}},2D:l(){8 7.4.q},1p:l(){8 7.4[0].q},24:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(7.4.q!=M.q||7.4[0].q!=M[0].q){8 1L}9 b=7.4.q,15=b,i,G,10=7.4[0].q,j;J{i=15-b;G=10;J{j=10-G;o(F.13(7.4[i][j]-M[i][j])>17.16){8 1L}}H(--G)}H(--b);8 2x},1q:l(){8 S.u(7.4)},1b:l(a){9 b=[],12=7.4.q,15=12,i,G,10=7.4[0].q,j;J{i=15-12;G=10;b[i]=[];J{j=10-G;b[i][j]=a(7.4[i][j],i+1,j+1)}H(--G)}H(--12);8 S.u(b)},2i:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}8(7.4.q==M.q&&7.4[0].q==M[0].q)},2j:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(!7.2i(M)){8 w}8 7.1b(l(x,i,j){8 x+M[i-1][j-1]})},2C:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(!7.2i(M)){8 w}8 7.1b(l(x,i,j){8 x-M[i-1][j-1]})},2B:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}8(7.4[0].q==M.q)},22:l(a){o(!a.4){8 7.1b(l(x){8 x*a})}9 b=a.1u?2x:1L;9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(!7.2B(M)){8 w}9 d=7.4.q,15=d,i,G,10=M[0].q,j;9 e=7.4[0].q,4=[],21,20,c;J{i=15-d;4[i]=[];G=10;J{j=10-G;21=0;20=e;J{c=e-20;21+=7.4[i][c]*M[c][j]}H(--20);4[i][j]=21}H(--G)}H(--d);9 M=S.u(4);8 b?M.2E(1):M},x:l(a){8 7.22(a)},32:l(a,b,c,d){9 e=[],12=c,i,G,j;9 f=7.4.q,1p=7.4[0].q;J{i=c-12;e[i]=[];G=d;J{j=d-G;e[i][j]=7.4[(a+i-1)%f][(b+j-1)%1p]}H(--G)}H(--12);8 S.u(e)},31:l(){9 a=7.4.q,1p=7.4[0].q;9 b=[],12=1p,i,G,j;J{i=1p-12;b[i]=[];G=a;J{j=a-G;b[i][j]=7.4[j][i]}H(--G)}H(--12);8 S.u(b)},1y:l(){8(7.4.q==7.4[0].q)},2A:l(){9 m=0,12=7.4.q,15=12,i,G,10=7.4[0].q,j;J{i=15-12;G=10;J{j=10-G;o(F.13(7.4[i][j])>F.13(m)){m=7.4[i][j]}}H(--G)}H(--12);8 m},2Z:l(x){9 a=w,12=7.4.q,15=12,i,G,10=7.4[0].q,j;J{i=15-12;G=10;J{j=10-G;o(7.4[i][j]==x){8{i:i+1,j:j+1}}}H(--G)}H(--12);8 w},30:l(){o(!7.1y){8 w}9 a=[],n=7.4.q,k=n,i;J{i=k-n;a.19(7.4[i][i])}H(--n);8 v.u(a)},1K:l(){9 M=7.1q(),1c;9 n=7.4.q,k=n,i,1s,1n=7.4[0].q,p;J{i=k-n;o(M.4[i][i]==0){2e(j=i+1;j<k;j++){o(M.4[j][i]!=0){1c=[];1s=1n;J{p=1n-1s;1c.19(M.4[i][p]+M.4[j][p])}H(--1s);M.4[i]=1c;1I}}}o(M.4[i][i]!=0){2e(j=i+1;j<k;j++){9 a=M.4[j][i]/M.4[i][i];1c=[];1s=1n;J{p=1n-1s;1c.19(p<=i?0:M.4[j][p]-M.4[i][p]*a)}H(--1s);M.4[j]=1c}}}H(--n);8 M},3h:l(){8 7.1K()},2z:l(){o(!7.1y()){8 w}9 M=7.1K();9 a=M.4[0][0],n=M.4.q-1,k=n,i;J{i=k-n+1;a=a*M.4[i][i]}H(--n);8 a},3f:l(){8 7.2z()},2y:l(){8(7.1y()&&7.2z()===0)},2Y:l(){o(!7.1y()){8 w}9 a=7.4[0][0],n=7.4.q-1,k=n,i;J{i=k-n+1;a+=7.4[i][i]}H(--n);8 a},3e:l(){8 7.2Y()},1Y:l(){9 M=7.1K(),1Y=0;9 a=7.4.q,15=a,i,G,10=7.4[0].q,j;J{i=15-a;G=10;J{j=10-G;o(F.13(M.4[i][j])>17.16){1Y++;1I}}H(--G)}H(--a);8 1Y},3d:l(){8 7.1Y()},2W:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}9 T=7.1q(),1p=T.4[0].q;9 b=T.4.q,15=b,i,G,10=M[0].q,j;o(b!=M.q){8 w}J{i=15-b;G=10;J{j=10-G;T.4[i][1p+j]=M[i][j]}H(--G)}H(--b);8 T},2w:l(){o(!7.1y()||7.2y()){8 w}9 a=7.4.q,15=a,i,j;9 M=7.2W(S.I(a)).1K();9 b,1n=M.4[0].q,p,1c,2v;9 c=[],2c;J{i=a-1;1c=[];b=1n;c[i]=[];2v=M.4[i][i];J{p=1n-b;2c=M.4[i][p]/2v;1c.19(2c);o(p>=15){c[i].19(2c)}}H(--b);M.4[i]=1c;2e(j=0;j<i;j++){1c=[];b=1n;J{p=1n-b;1c.19(M.4[j][p]-M.4[i][p]*M.4[j][i])}H(--b);M.4[j]=1c}}H(--a);8 S.u(c)},3c:l(){8 7.2w()},2d:l(){8 7.1b(l(x){8 F.2d(x)})},2V:l(x){8 7.1b(l(p){8(F.13(p-x)<=17.16)?x:p})},2n:l(){9 a=[];9 n=7.4.q,k=n,i;J{i=k-n;a.19(v.u(7.4[i]).2n())}H(--n);8 a.2K(\'\\n\')},26:l(a){9 i,4=a.4||a;o(1g(4[0][0])!=\'1f\'){9 b=4.q,15=b,G,10,j;7.4=[];J{i=15-b;G=4[i].q;10=G;7.4[i]=[];J{j=10-G;7.4[i][j]=4[i][j]}H(--G)}H(--b);8 7}9 n=4.q,k=n;7.4=[];J{i=k-n;7.4.19([4[i]])}H(--n);8 7}};S.u=l(a){9 M=25 S();8 M.26(a)};S.I=l(n){9 a=[],k=n,i,G,j;J{i=k-n;a[i]=[];G=k;J{j=k-G;a[i][j]=(i==j)?1:0}H(--G)}H(--n);8 S.u(a)};S.2X=l(a){9 n=a.q,k=n,i;9 M=S.I(n);J{i=k-n;M.4[i][i]=a[i]}H(--n);8 M};S.1R=l(b,a){o(!a){8 S.u([[F.1H(b),-F.1G(b)],[F.1G(b),F.1H(b)]])}9 d=a.1q();o(d.4.q!=3){8 w}9 e=d.1u();9 x=d.4[0]/e,y=d.4[1]/e,z=d.4[2]/e;9 s=F.1G(b),c=F.1H(b),t=1-c;8 S.u([[t*x*x+c,t*x*y-s*z,t*x*z+s*y],[t*x*y+s*z,t*y*y+c,t*y*z-s*x],[t*x*z-s*y,t*y*z+s*x,t*z*z+c]])};S.3b=l(t){9 c=F.1H(t),s=F.1G(t);8 S.u([[1,0,0],[0,c,-s],[0,s,c]])};S.39=l(t){9 c=F.1H(t),s=F.1G(t);8 S.u([[c,0,s],[0,1,0],[-s,0,c]])};S.38=l(t){9 c=F.1H(t),s=F.1G(t);8 S.u([[c,-s,0],[s,c,0],[0,0,1]])};S.2J=l(n,m){8 S.1j(n,m).1b(l(){8 F.2F()})};S.1j=l(n,m){9 a=[],12=n,i,G,j;J{i=n-12;a[i]=[];G=m;J{j=m-G;a[i][j]=0}H(--G)}H(--12);8 S.u(a)};l 14(){}14.23={24:l(a){8(7.1m(a)&&7.1h(a.K))},1q:l(){8 14.u(7.K,7.U)},2U:l(a){9 V=a.4||a;8 14.u([7.K.4[0]+V[0],7.K.4[1]+V[1],7.K.4[2]+(V[2]||0)],7.U)},1m:l(a){o(a.W){8 a.1m(7)}9 b=7.U.1C(a.U);8(F.13(b)<=17.16||F.13(b-F.1A)<=17.16)},1o:l(a){o(a.W){8 a.1o(7)}o(a.U){o(7.1m(a)){8 7.1o(a.K)}9 N=7.U.2f(a.U).2q().4;9 A=7.K.4,B=a.K.4;8 F.13((A[0]-B[0])*N[0]+(A[1]-B[1])*N[1]+(A[2]-B[2])*N[2])}1d{9 P=a.4||a;9 A=7.K.4,D=7.U.4;9 b=P[0]-A[0],2a=P[1]-A[1],29=(P[2]||0)-A[2];9 c=F.1x(b*b+2a*2a+29*29);o(c===0)8 0;9 d=(b*D[0]+2a*D[1]+29*D[2])/c;9 e=1-d*d;8 F.13(c*F.1x(e<0?0:e))}},1h:l(a){9 b=7.1o(a);8(b!==w&&b<=17.16)},2T:l(a){8 a.1h(7)},1v:l(a){o(a.W){8 a.1v(7)}8(!7.1m(a)&&7.1o(a)<=17.16)},1U:l(a){o(a.W){8 a.1U(7)}o(!7.1v(a)){8 w}9 P=7.K.4,X=7.U.4,Q=a.K.4,Y=a.U.4;9 b=X[0],1z=X[1],1B=X[2],1T=Y[0],1S=Y[1],1M=Y[2];9 c=P[0]-Q[0],2s=P[1]-Q[1],2r=P[2]-Q[2];9 d=-b*c-1z*2s-1B*2r;9 e=1T*c+1S*2s+1M*2r;9 f=b*b+1z*1z+1B*1B;9 g=1T*1T+1S*1S+1M*1M;9 h=b*1T+1z*1S+1B*1M;9 k=(d*g/f+h*e)/(g-h*h);8 v.u([P[0]+k*b,P[1]+k*1z,P[2]+k*1B])},1r:l(a){o(a.U){o(7.1v(a)){8 7.1U(a)}o(7.1m(a)){8 w}9 D=7.U.4,E=a.U.4;9 b=D[0],1l=D[1],1k=D[2],1P=E[0],1O=E[1],1Q=E[2];9 x=(1k*1P-b*1Q),y=(b*1O-1l*1P),z=(1l*1Q-1k*1O);9 N=v.u([x*1Q-y*1O,y*1P-z*1Q,z*1O-x*1P]);9 P=11.u(a.K,N);8 P.1U(7)}1d{9 P=a.4||a;o(7.1h(P)){8 v.u(P)}9 A=7.K.4,D=7.U.4;9 b=D[0],1l=D[1],1k=D[2],1w=A[0],18=A[1],1a=A[2];9 x=b*(P[1]-18)-1l*(P[0]-1w),y=1l*((P[2]||0)-1a)-1k*(P[1]-18),z=1k*(P[0]-1w)-b*((P[2]||0)-1a);9 V=v.u([1l*x-1k*z,1k*y-b*x,b*z-1l*y]);9 k=7.1o(P)/V.1u();8 v.u([P[0]+V.4[0]*k,P[1]+V.4[1]*k,(P[2]||0)+V.4[2]*k])}},1V:l(t,a){o(1g(a.U)==\'1f\'){a=14.u(a.1N(),v.k)}9 R=S.1R(t,a.U).4;9 C=a.1r(7.K).4;9 A=7.K.4,D=7.U.4;9 b=C[0],1E=C[1],1J=C[2],1w=A[0],18=A[1],1a=A[2];9 x=1w-b,y=18-1E,z=1a-1J;8 14.u([b+R[0][0]*x+R[0][1]*y+R[0][2]*z,1E+R[1][0]*x+R[1][1]*y+R[1][2]*z,1J+R[2][0]*x+R[2][1]*y+R[2][2]*z],[R[0][0]*D[0]+R[0][1]*D[1]+R[0][2]*D[2],R[1][0]*D[0]+R[1][1]*D[1]+R[1][2]*D[2],R[2][0]*D[0]+R[2][1]*D[1]+R[2][2]*D[2]])},1t:l(a){o(a.W){9 A=7.K.4,D=7.U.4;9 b=A[0],18=A[1],1a=A[2],2N=D[0],1l=D[1],1k=D[2];9 c=7.K.1t(a).4;9 d=b+2N,2h=18+1l,2o=1a+1k;9 Q=a.1r([d,2h,2o]).4;9 e=[Q[0]+(Q[0]-d)-c[0],Q[1]+(Q[1]-2h)-c[1],Q[2]+(Q[2]-2o)-c[2]];8 14.u(c,e)}1d o(a.U){8 7.1V(F.1A,a)}1d{9 P=a.4||a;8 14.u(7.K.1t([P[0],P[1],(P[2]||0)]),7.U)}},1Z:l(a,b){a=v.u(a);b=v.u(b);o(a.4.q==2){a.4.19(0)}o(b.4.q==2){b.4.19(0)}o(a.4.q>3||b.4.q>3){8 w}9 c=b.1u();o(c===0){8 w}7.K=a;7.U=v.u([b.4[0]/c,b.4[1]/c,b.4[2]/c]);8 7}};14.u=l(a,b){9 L=25 14();8 L.1Z(a,b)};14.X=14.u(v.1j(3),v.i);14.Y=14.u(v.1j(3),v.j);14.Z=14.u(v.1j(3),v.k);l 11(){}11.23={24:l(a){8(7.1h(a.K)&&7.1m(a))},1q:l(){8 11.u(7.K,7.W)},2U:l(a){9 V=a.4||a;8 11.u([7.K.4[0]+V[0],7.K.4[1]+V[1],7.K.4[2]+(V[2]||0)],7.W)},1m:l(a){9 b;o(a.W){b=7.W.1C(a.W);8(F.13(b)<=17.16||F.13(F.1A-b)<=17.16)}1d o(a.U){8 7.W.2k(a.U)}8 w},2k:l(a){9 b=7.W.1C(a.W);8(F.13(F.1A/2-b)<=17.16)},1o:l(a){o(7.1v(a)||7.1h(a)){8 0}o(a.K){9 A=7.K.4,B=a.K.4,N=7.W.4;8 F.13((A[0]-B[0])*N[0]+(A[1]-B[1])*N[1]+(A[2]-B[2])*N[2])}1d{9 P=a.4||a;9 A=7.K.4,N=7.W.4;8 F.13((A[0]-P[0])*N[0]+(A[1]-P[1])*N[1]+(A[2]-(P[2]||0))*N[2])}},1h:l(a){o(a.W){8 w}o(a.U){8(7.1h(a.K)&&7.1h(a.K.2j(a.U)))}1d{9 P=a.4||a;9 A=7.K.4,N=7.W.4;9 b=F.13(N[0]*(A[0]-P[0])+N[1]*(A[1]-P[1])+N[2]*(A[2]-(P[2]||0)));8(b<=17.16)}},1v:l(a){o(1g(a.U)==\'1f\'&&1g(a.W)==\'1f\'){8 w}8!7.1m(a)},1U:l(a){o(!7.1v(a)){8 w}o(a.U){9 A=a.K.4,D=a.U.4,P=7.K.4,N=7.W.4;9 b=(N[0]*(P[0]-A[0])+N[1]*(P[1]-A[1])+N[2]*(P[2]-A[2]))/(N[0]*D[0]+N[1]*D[1]+N[2]*D[2]);8 v.u([A[0]+D[0]*b,A[1]+D[1]*b,A[2]+D[2]*b])}1d o(a.W){9 c=7.W.2f(a.W).2q();9 N=7.W.4,A=7.K.4,O=a.W.4,B=a.K.4;9 d=S.1j(2,2),i=0;H(d.2y()){i++;d=S.u([[N[i%3],N[(i+1)%3]],[O[i%3],O[(i+1)%3]]])}9 e=d.2w().4;9 x=N[0]*A[0]+N[1]*A[1]+N[2]*A[2];9 y=O[0]*B[0]+O[1]*B[1]+O[2]*B[2];9 f=[e[0][0]*x+e[0][1]*y,e[1][0]*x+e[1][1]*y];9 g=[];2e(9 j=1;j<=3;j++){g.19((i==j)?0:f[(j+(5-i)%3)%3])}8 14.u(g,c)}},1r:l(a){9 P=a.4||a;9 A=7.K.4,N=7.W.4;9 b=(A[0]-P[0])*N[0]+(A[1]-P[1])*N[1]+(A[2]-(P[2]||0))*N[2];8 v.u([P[0]+N[0]*b,P[1]+N[1]*b,(P[2]||0)+N[2]*b])},1V:l(t,a){9 R=S.1R(t,a.U).4;9 C=a.1r(7.K).4;9 A=7.K.4,N=7.W.4;9 b=C[0],1E=C[1],1J=C[2],1w=A[0],18=A[1],1a=A[2];9 x=1w-b,y=18-1E,z=1a-1J;8 11.u([b+R[0][0]*x+R[0][1]*y+R[0][2]*z,1E+R[1][0]*x+R[1][1]*y+R[1][2]*z,1J+R[2][0]*x+R[2][1]*y+R[2][2]*z],[R[0][0]*N[0]+R[0][1]*N[1]+R[0][2]*N[2],R[1][0]*N[0]+R[1][1]*N[1]+R[1][2]*N[2],R[2][0]*N[0]+R[2][1]*N[1]+R[2][2]*N[2]])},1t:l(a){o(a.W){9 A=7.K.4,N=7.W.4;9 b=A[0],18=A[1],1a=A[2],2M=N[0],2L=N[1],2Q=N[2];9 c=7.K.1t(a).4;9 d=b+2M,2p=18+2L,2m=1a+2Q;9 Q=a.1r([d,2p,2m]).4;9 e=[Q[0]+(Q[0]-d)-c[0],Q[1]+(Q[1]-2p)-c[1],Q[2]+(Q[2]-2m)-c[2]];8 11.u(c,e)}1d o(a.U){8 7.1V(F.1A,a)}1d{9 P=a.4||a;8 11.u(7.K.1t([P[0],P[1],(P[2]||0)]),7.W)}},1Z:l(a,b,c){a=v.u(a);a=a.1N();o(a===w){8 w}b=v.u(b);b=b.1N();o(b===w){8 w}o(1g(c)==\'1f\'){c=w}1d{c=v.u(c);c=c.1N();o(c===w){8 w}}9 d=a.4[0],18=a.4[1],1a=a.4[2];9 e=b.4[0],1W=b.4[1],1X=b.4[2];9 f,1i;o(c!==w){9 g=c.4[0],2l=c.4[1],2t=c.4[2];f=v.u([(1W-18)*(2t-1a)-(1X-1a)*(2l-18),(1X-1a)*(g-d)-(e-d)*(2t-1a),(e-d)*(2l-18)-(1W-18)*(g-d)]);1i=f.1u();o(1i===0){8 w}f=v.u([f.4[0]/1i,f.4[1]/1i,f.4[2]/1i])}1d{1i=F.1x(e*e+1W*1W+1X*1X);o(1i===0){8 w}f=v.u([b.4[0]/1i,b.4[1]/1i,b.4[2]/1i])}7.K=a;7.W=f;8 7}};11.u=l(a,b,c){9 P=25 11();8 P.1Z(a,b,c)};11.2I=11.u(v.1j(3),v.k);11.2H=11.u(v.1j(3),v.i);11.2G=11.u(v.1j(3),v.j);11.36=11.2I;11.35=11.2H;11.3j=11.2G;9 $V=v.u;9 $M=S.u;9 $L=14.u;9 $P=11.u;',62,206,'||||elements|||this|return|var||||||||||||function|||if||length||||create|Vector|null|||||||||Math|nj|while||do|anchor||||||||Matrix||direction||normal||||kj|Plane|ni|abs|Line|ki|precision|Sylvester|A2|push|A3|map|els|else||undefined|typeof|contains|mod|Zero|D3|D2|isParallelTo|kp|distanceFrom|cols|dup|pointClosestTo|np|reflectionIn|modulus|intersects|A1|sqrt|isSquare|X2|PI|X3|angleFrom|mod1|C2|mod2|sin|cos|break|C3|toRightTriangular|false|Y3|to3D|E2|E1|E3|Rotation|Y2|Y1|intersectionWith|rotate|v12|v13|rank|setVectors|nc|sum|multiply|prototype|eql|new|setElements|case|each|PA3|PA2|part|new_element|round|for|cross|product|AD2|isSameSizeAs|add|isPerpendicularTo|v22|AN3|inspect|AD3|AN2|toUnitVector|PsubQ3|PsubQ2|v23|dot|divisor|inverse|true|isSingular|determinant|max|canMultiplyFromLeft|subtract|rows|col|random|ZX|YZ|XY|Random|join|N2|N1|D1|slice|default|N3|dimensions|switch|liesIn|translate|snapTo|augment|Diagonal|trace|indexOf|diagonal|transpose|minor|row|isAntiparallelTo|ZY|YX|acos|RotationZ|RotationY|liesOn|RotationX|inv|rk|tr|det|toDiagonalMatrix|toUpperTriangular|version|XZ'.split('|'),0,{}));(function() {
  function Updater() {
    this.updatees = [];
  };

  Updater.prototype = {
    update: function() {
      for(var i = 0; i < this.updatees.length; i++) {
        this.updatees[i].update();
      }
    },

    add: function(updatee) {
      this.updatees.push(updatee);
    },

    remove: function(updatee) {
      for(var i = 0; i < this.updatees.length; i++) {
        if(this.updatees[i] === updatee) {
          this.updatees.splice(i, 1);
          break;
        }
      }
    }
  };

  this.Updater = Updater;
}).call(this);;(function() {
  function Util() {};

  Util.prototype = {
    inInstances: function(obj, instances) {
      for(var i = 0; i < instances.length; i++) {
        if(obj instanceof instances[i]) {
          return true;
        }
      }

      return false;
    },

    filter: function(arr, fn) {
      var ret = [];
      for(var i = 0; i < arr.length; i++) {
        if(fn(arr[i])) {
          ret.push(arr[i]);
        }
      }

      return ret;
    },

    addAll: function(arr, items) {
      for(var i = 0; i < items.length; i++) {
        arr.push(items[i]);
      }

      return arr;
    }
  };

  this.Util = Util;
}).call(this);
